<!DOCTYPE html>
<html lang="en">
<head>
    </head>
<body>
    <script>
    const form = document.getElementById('performanceForm');
    const formTitle = document.getElementById('formTitle');
    const successMessage = document.getElementById('formSuccessMessage');
    const errorMessage = document.getElementById('formErrorMessage');
    const userRoleSelect = document.getElementById('userRole');

    // Select all relevant input fields using their classes/attributes
    const outstandingFields = document.querySelectorAll('.outstanding-field');
    const netGrowthPeriodGroups = document.querySelectorAll('.net-growth-period-group');
    const freshCustomerPeriodGroups = document.querySelectorAll('.fresh-customer-period-group');
    const visitsPeriodGroups = document.querySelectorAll('.visits-period-group');
    const callsPeriodGroups = document.querySelectorAll('.calls-period-group');

    const actualCustomerBaseField = document.getElementById('actualCustomerBase');


    // IMPORTANT: Replace this with YOUR Google Apps Script Web App URL
    const appsScriptURL = 'https://script.google.com/macros/s/AKfycbxnNMtVjeHh4M87Pn61_jxzcs902win5sToqQQDRR6_RFKckZOsk9zZlDbGD2juW7NC/exec';

    // Global variable to store fetched data
    let fetchedData = null; // Will store { latestValues, capturedPeriods, currentQuarterName, currentMonth, currentYear }

    // Admin override from URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const isAdmin = urlParams.get('admin') === 'true';

    // Helper function to get quarter name from month (0-indexed)
    function getQuarterName(monthIndex) {
        if (monthIndex >= 0 && monthIndex <= 2) return 'Q1'; // Jan-Mar
        if (monthIndex >= 3 && monthIndex <= 5) return 'Q2'; // Apr-Jun
        if (monthIndex >= 6 && monthIndex <= 8) return 'Q3'; // Jul-Sep
        if (monthIndex >= 9 && monthIndex <= 11) return 'Q4'; // Oct-Dec
        return '';
    }

    /**
     * Determines the Nth Monday-Saturday week of the month a date falls into.
     * Returns 0 if no valid week is found within the current month context.
     */
    function getWeekNumberOfMonth(date) {
        const d = new Date(date);
        d.setHours(0, 0, 0, 0); // Normalize to start of day

        const year = d.getFullYear();
        const month = d.getMonth(); // 0-indexed

        // If the day is Sunday, it cannot be part of a Mon-Sat week
        if (d.getDay() === 0) { // Sunday
            return 0;
        }

        let weekNumber = 0;
        let tempDate = new Date(year, month, 1); // Start checking from 1st of the month

        // Find the first Monday of the month
        while (tempDate.getDay() !== 1) { // 1 is Monday
            tempDate.setDate(tempDate.getDate() + 1);
            if (tempDate.getMonth() !== month) {
                // If we cross into the next month before finding the first Monday,
                // it means there are no Mon-Sat weeks starting in this month that could contain 'd'.
                return 0;
            }
        }

        // Now tempDate is the first Monday of the month
        for (let i = 1; i <= 4; i++) { // Check for weeks 1 through 4
            const weekStart = new Date(tempDate);
            const weekEnd = new Date(tempDate);
            weekEnd.setDate(weekEnd.getDate() + 5); // Saturday of the current week

            // Check if the input date 'd' falls within this Mon-Sat range
            if (d.getTime() >= weekStart.getTime() && d.getTime() <= weekEnd.getTime()) {
                weekNumber = i;
                break; // Found the week, exit loop
            }

            // Move tempDate to the Monday of the next week for the next iteration
            tempDate.setDate(tempDate.getDate() + 7);
            // If we cross into the next month, it means there are no more full Mon-Sat weeks
            // starting within the current month for 'd' to possibly fall into.
            if (tempDate.getMonth() !== month) {
                break;
            }
        }
        return weekNumber;
    }


    /**
     * Disables a form field and optionally sets its value.
     * Adds 'disabled-field-group' class to the parent .form-group for styling.
     */
    function disableField(field, value = '') {
        field.disabled = true;
        field.value = value;
        field.parentElement.classList.add('disabled-field-group');
    }

    /**
     * Enables a form field and clears its value.
     * Removes 'disabled-field-group' class from the parent .form-group.
     */
    function enableField(field) {
        field.disabled = false;
        field.value = '';
        field.parentElement.classList.remove('disabled-field-group');
    }

    /**
     * Main function to initialize and apply form field logic.
     * Fetches data, applies role-based, period-based, and week-based disabling.
     */
    async function initializeFormFields() {
        // First, disable all fields temporarily, they will be enabled based on logic
        document.querySelectorAll('input, select').forEach(field => {
            field.disabled = true; // Disable all
            if (field.parentElement.classList.contains('disabled-field-group')) {
                field.parentElement.classList.remove('disabled-field-group');
            }
        });

        // Always enable Branch, Employee Name, and User Role for basic form operation
        document.getElementById('branch').disabled = false;
        document.getElementById('employeeName').disabled = false;
        userRoleSelect.disabled = false;


        if (isAdmin) {
            console.log("Admin mode: All fields are enabled.");
            document.querySelectorAll('input, select').forEach(field => {
                field.disabled = false;
                field.parentElement.classList.remove('disabled-field-group');
            });
            return; // Exit if in admin mode
        }

        // Fetch data from Apps Script
        try {
            const response = await fetch(appsScriptURL);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            fetchedData = await response.json(); // Store for later use
            console.log("Fetched Data:", fetchedData);

            if (fetchedData.error) {
                console.error("Apps Script Error:", fetchedData.error);
                alert("Error fetching data from sheet: " + fetchedData.error);
                return;
            }

        } catch (error) {
            console.error('Error fetching data:', error);
            alert('Failed to load previous data. Please check your internet connection or try again later.');
            return;
        }

        const { latestValues, capturedPeriods, currentQuarterName, currentMonth, currentYear } = fetchedData;
        const selectedRole = userRoleSelect.value;
        const today = new Date();
        const currentWeekNumber = getWeekNumberOfMonth(today);

        // --- Apply Logic for Each Category ---

        // Outstanding Category Logic (Role-based and Period-based)
        outstandingFields.forEach(field => {
            const category = field.closest('.outstanding-period-group').dataset.category; // "Outstanding"
            const period = field.closest('.outstanding-period-group').dataset.period; // "FY", "Quarter", "Month"
            const fieldName = field.name;

            if (selectedRole === 'Others') {
                disableField(field, latestValues[fieldName] || ''); // Disable and show value if available
            } else { // Branch in Charge
                if (period === 'FY') {
                    // FY fields for Outstanding are always editable for Branch in Charge
                    enableField(field);
                    field.value = latestValues[fieldName] || ''; // Populate if exists
                } else if (period === 'Quarter') {
                    const captureKey = `${category}_${currentQuarterName}_${currentYear}`;
                    if (capturedPeriods[captureKey]) {
                        disableField(field, latestValues[fieldName] || '');
                    } else {
                        enableField(field);
                        field.value = latestValues[fieldName] || '';
                    }
                } else if (period === 'Month') {
                    const captureKey = `${category}_${currentMonth}_${currentYear}`;
                    if (capturedPeriods[captureKey]) {
                        disableField(field, latestValues[fieldName] || '');
                    } else {
                        enableField(field);
                        field.value = latestValues[fieldName] || '';
                    }
                }
            }
        });

        // Net Growth Target, Fresh Customer, Visits, Calls Logic (Period-based, including Weekly)
        const categoriesToProcess = [
            { id: 'net-growth', groups: netGrowthPeriodGroups },
            { id: 'fresh-customer', groups: freshCustomerPeriodGroups },
            { id: 'visits', groups: visitsPeriodGroups },
            { id: 'calls', groups: callsPeriodGroups }
        ];

        categoriesToProcess.forEach(cat => {
            cat.groups.forEach(group => {
                const category = group.dataset.category; // e.g., "Net Growth", "Fresh Customer", "Visits", "Calls"
                const period = group.dataset.period; // "FY", "Quarter", "Month", "Week"
                const inputFields = group.querySelectorAll('input');

                inputFields.forEach(field => {
                    const fieldName = field.name;

                    if (period === 'FY') {
                        // FY for Net Growth only. Other categories don't have FY targets per spec.
                        // Assuming FY targets are always editable, unless a different rule is defined.
                        enableField(field);
                        field.value = latestValues[fieldName] || '';
                    } else if (period === 'Quarter') {
                        const captureKey = `${category}_${currentQuarterName}_${currentYear}`;
                        if (capturedPeriods[captureKey]) {
                            disableField(field, latestValues[fieldName] || '');
                        } else {
                            enableField(field);
                            field.value = latestValues[fieldName] || '';
                        }
                    } else if (period === 'Month') {
                        const captureKey = `${category}_${currentMonth}_${currentYear}`;
                        if (capturedPeriods[captureKey]) {
                            disableField(field, latestValues[fieldName] || '');
                        } else {
                            enableField(field);
                            field.value = latestValues[fieldName] || '';
                        }
                    } else if (period === 'Week') {
                        const fieldWeek = parseInt(field.dataset.week);
                        if (fieldWeek === currentWeekNumber) {
                            enableField(field);
                            field.value = latestValues[fieldName] || '';
                        } else {
                            disableField(field, latestValues[fieldName] || ''); // Show value for other weeks but disabled
                        }
                    }
                });
            });
        });

        // Actual Customer Base (single field, always enabled, show latest value)
        if (actualCustomerBaseField) {
            enableField(actualCustomerBaseField);
            actualCustomerBaseField.value = latestValues[actualCustomerBaseField.name] || '';
        }

        // Final check: if user role isn't selected, keep relevant fields disabled
        if (selectedRole === '') {
            outstandingFields.forEach(field => disableField(field, '')); // Disable Outstanding if role not set
        }

        // Ensure Branch and Employee Name are always enabled after all other logic
        document.getElementById('branch').disabled = false;
        document.getElementById('employeeName').disabled = false;
    }


    // Event listener for User Role dropdown to trigger form update
    userRoleSelect.addEventListener('change', initializeFormFields);

    // Initial form setup when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initializeFormFields);


    // Form submission handler
    form.addEventListener('submit', async function(event) {
        event.preventDefault();

        successMessage.style.display = 'none';
        errorMessage.style.display = 'none';

        const submitButton = form.querySelector('button[type="submit"]');
        submitButton.disabled = true;
        submitButton.textContent = 'Submitting...';

        const formData = new FormData(form);

        // Filter out disabled fields to avoid sending old values
        const dataToSend = {};
        for (let [key, value] of formData.entries()) {
            const inputElement = form.elements[key];
            // Only include fields that are not disabled
            // Also, exclude "bot-field" if it exists (hidden honey pot field)
            if (inputElement && !inputElement.disabled && key !== 'bot-field') {
                dataToSend[key] = value;
            }
        }
        
        // Add current timestamp for form submission (optional, but good for tracking client time)
        // This is separate from the Apps Script timestamp
        dataToSend['Client Submit Timestamp'] = new Date().toISOString();


        try {
            // Use URLSearchParams for x-www-form-urlencoded to match Apps Script's e.parameter
            const response = await fetch(appsScriptURL, {
                method: 'POST',
                body: new URLSearchParams(dataToSend),
            });

            if (response.ok) {
                const resultText = await response.text();
                console.log("Apps Script response text:", resultText);

                if (resultText.trim() === 'Success') {
                    form.style.display = 'none';
                    formTitle.style.display = 'none';
                    successMessage.style.display = 'block';
                    form.reset(); // Clear form values
                } else {
                    console.error("Apps Script returned unexpected text:", resultText);
                    errorMessage.querySelector('p').textContent = `Submission failed: Unexpected response from server.`;
                    errorMessage.style.display = 'block';
                }
            } else {
                console.error("HTTP Error during submission:", response.status, response.statusText);
                errorMessage.querySelector('p').textContent = `Server error: ${response.status} ${response.statusText}. Please try again.`;
                errorMessage.style.display = 'block';
            }
        } catch (error) {
            console.error('Error submitting form:', error);
            errorMessage.querySelector('p').textContent = `Network error: ${error.message}. Please check your connection.`;
            errorMessage.style.display = 'block';
        } finally {
            submitButton.disabled = false;
            submitButton.textContent = 'Submit Performance Data';
        }
    });

    /**
     * Resets the form after submission or error.
     * Hides messages, shows form, clears values, and re-applies dynamic logic.
     */
    function resetForm() {
        successMessage.style.display = 'none';
        errorMessage.style.display = 'none';
        formTitle.style.display = 'block';
        form.style.display = 'block';
        form.reset(); // Reset all form fields to their default empty state
        userRoleSelect.value = ''; // Ensure role is reset
        initializeFormFields(); // IMPORTANT: Re-apply disabling/enabling logic and re-fetch data
    }
</script>
</body>
</html>